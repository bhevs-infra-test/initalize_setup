# [BH EVS] 펌웨어 개발 CI/CD 도입을 위한 젠킨스 정책 수립안

**문서 목적:** 본 문서는 펌웨어 개발 프로세스의 자동화 및 표준화를 위해 젠킨스(Jenkins)를 도입하고, 이에 필요한 핵심 정책을 수립하여 개발 생산성과 펌웨어 품질의 일관성을 확보하는 것을 목적으로 한다.

---

## 1. 젠킨스(Jenkins)란?

젠킨스는 **지속적 통합(CI, Continuous Integration)** 및 **지속적 배포(CD, Continuous Delivery/Deployment)**를 지원하는 업계 표준 오픈소스 **자동화 서버**입니다.

* **핵심 기능:** 젠킨스는 파이프라인의 모든 단계를 조율하는 **"지휘자(Orchestrator)"**입니다. 개발자가 코드를 수정할 때마다 발생하는 반복적인 작업(빌드, 테스트, 패키징, 배포)을 자동화하기 위해 **연동된 전문 도구(컴파일러, 분석 툴, 저장소)를 호출**하고 그 흐름을 제어합니다.

* **특징 (Source: Jenkins.io):**
    * **플러그인(Plugin):** 수천 개의 플러그인을 통해 Git, SVN, Coverity, Nexus, Docker 등 거의 모든 개발 도구와 쉽게 연동할 수 있습니다.
    * **분산 빌드(Distributed Builds):** 여러 대의 에이전트(Agent) 서버를 두어, Windows/Linux 등 다양한 환경의 빌드를 동시에 처리할 수 있습니다.
    * **Pipeline as Code:** `Jenkinsfile`이라는 코드를 통해 파이프라인 전체를 스크립트로 정의하고 버전 관리가 가능합니다.

펌웨어 환경에서 젠킨스는 **"모든 펌웨어 빌드 작업을 중앙에서 통제하고, 신뢰할 수 있는 펌웨어 파일(`.bin`, `.hex`)을 생성, 관리, 추적"**하는 핵심 인프라 역할을 수행합니다.

---

## 2. 현재 상황(AS-IS) 및 개선 목표(TO-BE)

### 2-1. AS-IS (현재 문제점)

* **빌드 환경의 파편화:** 개발자 개인 PC(로컬)에서 펌웨어를 빌드하여, 동일한 소스 코드임에도 PC 환경(라이브러리, 컴파일러 버전 등)에 따라 빌드 결과가 달라질 위험이 존재합니다.
* **수동적인 산출물 공유:** 빌드된 펌웨어 파일을 메일, 메신저, NAS(네트워크 드라이브) 등을 통해 수동으로 공유합니다.
* **버전 관리의 혼란:** `_최종`, `_진짜최종`, `_수정` 등 파일명 기반의 버전 관리로 인해, 어떤 파일이 어떤 소스 코드로 만들어졌는지 이력 추적이 어렵고 혼선이 발생합니다.
* **반복 작업 및 휴먼 에러:** 개발자가 코드 수정 외에 빌드, 파일 복사, 공유, 테스트 요청 등 부수적인 수동 작업을 반복해야 하며, 이 과정에서 실수(Human Error)가 발생할 가능성이 있습니다.

### 2-2. TO-BE (개선 목표)

* **빌드 자동화 및 표준화:** 개발자가 코드를 `Push`하면, 젠킨스가 표준화된 환경에서 펌웨어를 **자동으로 빌드**하도록 조율합니다.
* **산출물 중앙 관리:** 모든 빌드 산출물(펌웨어 파일)은 젠킨스의 제어에 따라 **Nexus/Artifactory**와 같은 중앙 저장소에 **자동으로 업로드되고 버전이 부여**됩니다.
* **신뢰성 및 추적성 확보:** 모든 펌웨어 파일은 어떤 소스 코드(Git Commit)로, 언제, 어떻게 빌드되었는지 **완전한 이력 추적**이 가능해집니다.
* **신속한 테스트 피드백:** 개발자는 젠킨스 알림을 통해 빌드 성공/실패 여부를 즉시 확인하고, 중앙 저장소(Nexus)에서 **검증된 파일을 다운로드**하여 즉시 하드웨어(H/W) 테스트를 수행할 수 있습니다.

---

## 3. 젠킨스의 역할과 연동 도구

젠킨스는 파이프라인을 **조율(Orchestration)**하고, 실제 작업은 **연동된 전문 도구(Tools)**가 **실행(Execution)**합니다.

| 자동화 영역 | 젠킨스의 역할 (조율) | 연동 도구의 역할 (실행) |
| :--- | :--- | :--- |
| **코드 관리** | Git 플러그인을 통해 "Checkout" 명령 **호출** | `Git` 클라이언트가 소스 코드를 서버로 다운로드 **실행** |
| **펌웨어 빌드** | `make`, `bat` 등 빌드 스크립트 **호출** | `IAR`, `Keil`, `GCC` 등 **펌웨어 컴파일러**가 컴파일 **실행** |
| **정적 분석** | **Coverity** 플러그인 또는 분석 스크립트 **호출** | **Coverity 툴**이 소스 코드를 스캔하고 분석 **실행** |
| **테스트 자동화**| 유닛 테스트 스크립트(Python, Shell 등) **호출** | `CUnit`/`GTest` (테스트 프레임워크)가 테스트 **실행**<br/>`REST API 클라이언트` (Python, curl)가 테스트 API **호출** |
| **산출물 관리** | `Nexus/Artifactory Uploader` 플러그인 **호출** | **Nexus/Artifactory** 서버가 파일을 수신하여 저장/버전 관리 **실행** |
| **알림** | `Slack/Email` 플러그인을 통해 메시지 전송 **요청** | `Slack API` 또는 `SMTP 서버`가 메시지를 **발송** |

---

## 4. 작업(Job) 예시 및 역할 구분

| 작업 예시 | 4-1. 비공식(개발) 빌드 | 4-2. 공식(릴리스) 빌드 | 4-3. 주기적인 작업 |
| :--- | :--- | :--- | :--- |
| **목적** | 개발자의 신속한 기능 검증 및 H/W 테스트 | QA팀 전달 및 최종 릴리스 | 야간 빌드 및 리포트 생성 |
| **시작 시점** | **코드 변경 감지 시** (개발자가 `feature` 브랜치에 `Push`) | **1. Git 태그(Tag) 생성 시** (`v1.2.0`)<br/>**2. 수동 버튼 클릭 시** (관리자) | **주기적인 스케줄링** (매일 자정 등) |
| **주요 작업<br/>(파이프라인)** | 1. **[젠킨스]** Git Push 감지<br/>2. **[젠킨스]** 빌드 스크립트 **호출**<br/>3. **[컴파일러]** 펌웨어 빌드 **실행**<br/>4. **[젠킨스]** **Coverity** 분석 **호출**<br/>5. **[Coverity]** 코드 스캔 **실행**<br/>6. **[젠킨스]** Nexus 업로드 **명령**<br/>7. **[Nexus]** `SNAPSHOT` 저장 **실행**<br/>8. **[젠킨스]** Slack/메일 알림 **발송** | 1. **[젠킨스]** Git 태그 생성 감지<br/>2. **[젠킨스]** 빌드 스크립트 **호출**<br/>3. **[컴파일러]** 펌웨어 빌드 **실행**<br/>4. **[젠킨스]** 암호화 스크립트 **호출**<br/>5. **[외부툴]** 바이너리 후처리 **실행**<br/>6. **[젠킨스]** Nexus 업로드 **명령**<br/>7. **[Nexus]** `Release` 저장 **실행**<br/>8. **[젠킨스]** QA팀/개발팀 알림 **발송** | 1. **[젠킨스]** 스케줄러 작동<br/>2. **[젠킨스]** `main` 브랜치 **Checkout**<br/>3. **[젠킨스]** 빌드 및 테스트 **호출**<br/>4. **[젠킨스]** HIL 테스트 **호출**<br/>5. **[테스트 H/W]** 펌웨어 플래싱/테스트 **실행**<br/>6. **[젠킨스]** 결과 리포트 취합<br/>7. **[젠킨스]** 대시보드 게시 및 메일 **발송** |

---

## 5. 향후 계획 및 논의 사항

* **Nexus/Artifactory 도입:** 젠킨스와 연동할 **산출물 중앙 저장소(Nexus OSS 등)**의 서버를 조속히 확보하고 구축해야 합니다. (필수)
* **HIL(Hardware-in-the-Loop) 테스트 자동화:** 젠킨스 에이전트에 Cyclone 프로그래머, JTAG 등 H/W 테스트 장비를 연결하여, 펌웨어 빌드부터 타겟 보드 플래싱까지 완전 자동화하는 방안을 검토합니다.
* **파라미터화 빌드(Parameterized Build) 도입:** 빌드 시 타겟 모델(예: `MODEL_A`, `MODEL_B`)이나 컴파일 옵션을 개발자가 선택하여 빌드할 수 있는 동적 빌드 파이프라인을 구축합니다.
* **개발자 교육 및 전파:** 본 정책이 확정되면, 개발팀을 대상으로 젠킨스 사용법 및 새로운 깃 브랜치/빌드 프로세스에 대한 교육 세션을 진행합니다.

---

## 6. 수립이 필요한 핵심 정책

젠킨스 도입의 성공은 기술이 아닌 **"합의된 규칙(정책)"**을 준수하는 것에 달려있습니다.

### 6-1. 젠킨스 활용 범위 및 사용전략

* **활용 범위:** 펌웨어의 빌드, 품질 검사, 산출물 관리 및 배포 전(前) 단계까지의 모든 프로세스를 젠킨스로 자동화합니다.
* **사용 전략:**
    * **Pipeline as Code:** 모든 파이프라인은 `Jenkinsfile` (코드)로 작성하여 Git에서 소스 코드와 함께 버전 관리합니다.
    * **템플릿 제공 (Shared Library):** DevOps 담당자(혹은 담당팀)가 표준화된 빌드/업로드 파이프라인 템플릿을 **"공유 라이브러리"**로 제공하고, 개발자는 이를 가져와(import) 사용합니다.

### 6-2. 공식 빌드 vs 비공식(개발자 테스트용) 빌드

* **비공식(개발) 빌드:**
    * **정의:** 개발자가 `feature` 브랜치에 Push할 때마다 젠킨스가 실행하는 빌드.
    * **목적:** 코드 통합 검증 및 개발자의 신속한 H/W 테스트 지원.
    * **산출물:** Nexus의 `SNAPSHOT` 저장소에 저장. (예: `Appl-1.2-SNAPSHOT.bin`)
* **공식(릴리스) 빌드:**
    * **정의:** `main` 브랜치에 병합되거나, `v1.2.0` 같은 Git 태그가 생성될 때 실행하는 빌드.
    * **목적:** QA팀 전달, 인증, 최종 릴리스 등 공식적인 용도.
    * **산출물:** Nexus의 `Release` 저장소에 저장. (예: `Appl-1.2.0.bin`)
* **로컬 빌드 (개발자 PC):**
    * **정책:** 개발자 로컬 PC에서 빌드한 펌웨어 파일은 **"공식/비공식 테스트, 공유, 배포 목적으로 절대 사용할 수 없음"**을 원칙으로 합니다. (오직 개인 디버깅 용도로만 한정)

### 6-3. 깃 브랜치 전략

* **`main` (또는 `master`):**
    * **항상 배포 가능한** 상태의 브랜치.
    * **직접 Push 금지** (Git 저장소에서 `Protected Branch`로 설정)
* **`feature/*` (예: `feature/login-logic`):**
    * 모든 신규 기능 개발 및 버그 수정은 `feature` 브랜치에서 수행.
* **병합 전략:** `feature` 브랜치 작업 완료 -> `Pull Request (PR)` 생성 -> 코드 리뷰 -> `main` 브랜치로 병합.

### 6-4. 산출물에 대한 관리 방안

* **유일한 창구:** 모든 펌웨어 산출물(공식/비공식)은 **Nexus/Artifactory가 유일한 관리 창구**입니다.
* **NAS (네트워크 드라이브):** 기존 NAS는 레거시 파일 보관 용도로만 사용하며, 신규 펌웨어 산출물 저장을 **금지**합니다.
* **Mail (메일):** 젠킨스 빌드 성공/실패 **알림(Notification)** 용도로만 사용합니다. 알림 메일 본문에 산출물을 다운로드할 수 있는 **Nexus URL 링크**를 포함시키며, **펌웨어 파일을 메일에 직접 첨부하는 것을 절대 금지**합니다.

### 6-5. 산출물 관리 (백업, 저장 주기)

* **백업 주체:** 펌웨어 산출물의 백업은 젠킨스가 아닌 **Nexus/Artifactory** 서버가 담당합니다. (Nexus 서버의 데이터 볼륨을 주기적으로 백업)
* **저장 주기 (Retention Policy):** Nexus의 "Cleanup Policy" 기능을 통해 저장 주기를 자동화합니다.
    * **공식 릴리스 (Release):** **영구 보관** (또는 회사의 품질보증 규정에 따름)
    * **비공식 스냅샷 (Snapshot):** 디스크 용량 확보를 위해 **최근 7일** 또는 **최신 5개**의 빌드만 보관하고, 오래된 산출물은 **자동으로 삭제**합니다.