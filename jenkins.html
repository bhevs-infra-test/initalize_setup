<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>[BH EVS] 펌웨어 개발 CI/CD 도입을 위한 젠킨스 정책 수립안</title>
    <style>
        /* 기본 가독성을 위한 스타일 (선택 사항) */
        mark {
            font-weight: bold;
            background-color: #FFEE90;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Malgun Gothic", "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        h1, h2, h3 {
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 16px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        code {
            background-color: #f6f8fa;
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }
        .option-card {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-left: 5px solid #007bff;
            padding: 10px 15px;
            margin: 10px 0;
        }
        .option-card strong {
            display: block;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
    </style>
</head>
<body>

<h1>[BH EVS] 펌웨어 개발 CI/CD 도입을 위한 젠킨스 정책 수립안</h1>

<p><strong>문서 목적:</strong> 본 문서는 펌웨어 개발 프로세스의 자동화 및 표준화를 위해 젠킨스(Jenkins)를 도입하고, 이에 필요한 핵심 정책을 수립하여 개발 생산성과 펌웨어 품질의 일관성을 확보하는 것을 목적으로 한다.</p>

<hr>

<h2>1. 젠킨스(Jenkins)란?</h2>

<p>젠킨스는 <strong>지속적 통합(CI, Continuous Integration)</strong> 및 <strong>지속적 배포(CD, Continuous Delivery/Deployment)</strong>를 지원하는 업계 표준 오픈소스 <strong>자동화 서버</strong>입니다.</p>

<ul>
    <li><strong>핵심 기능:</strong> 젠킨스는 파이프라인의 모든 단계를 조율하는 역할을 수행합니다.</li>
    <li>개발자가 코드를 수정할 때마다 발생하는 <mark>반복적인 작업(빌드, 테스트, 패키징, 배포)을 자동화하기 위해 연동된 전문 도구(컴파일러, 분석 툴, 저장소)를 호출하고 그 흐름을 제어</mark>합니다.</li>
    <li><strong>특징:</strong>
        <ul>
            <li><strong>플러그인(Plugin):</strong> 수천 개의 플러그인을 통해 Git, SVN, Coverity, Nexus, Docker 등 거의 모든 개발 도구와 쉽게 연동할 수 있습니다.</li>
            <li><strong>분산 빌드(Distributed Builds):</strong> 여러 대의 에이전트(Agent) 서버를 두어, Windows/Linux 등 다양한 환경의 빌드를 동시에 처리할 수 있습니다.</li>
        </ul>
    </li>
</ul>

<p>펌웨어 개발 환경에서 젠킨스는 <mark>모든 펌웨어 빌드 작업을 중앙에서 통제하고, 신뢰할 수 있는 펌웨어 파일(<code>.bin</code>, <code>.hex</code>)을 생성, 관리, 추적</mark>하는 핵심 인프라 역할을 수행합니다.</p>

<hr>

<h2>2. 현재 상황(AS-IS) 및 개선 목표(TO-BE)</h2>

<h3>2-1. AS-IS (현재 문제점)</h3>
<ul>
    <li><strong>빌드 환경의 파편화:</strong> <mark>개발자 개인 PC(로컬)에서 펌웨어를 빌드</mark>하여, 동일한 소스 코드임에도 PC 환경(라이브러리, 컴파일러 버전 등)에 따라 빌드 결과가 달라질 위험이 존재합니다.</li>
    <li><strong>수동적인 산출물 공유:</strong> 빌드된 펌웨어 파일을 메일, 메신저, NAS(네트워크 드라이브) 등을 통해 <mark>수동으로 공유</mark>합니다.</li>
    <li><strong>반복 작업 및 휴먼 에러:</strong> 개발자가 코드 수정 외에 빌드, 파일 복사, 공유, 테스트 요청 등 부수적인 <mark>수동 작업을 반복해야 하며, 이 과정에서 실수(Human Error)가 발생할 가능성</mark>이 높습니다.</li>
</ul>

<h3>2-2. TO-BE (개선 목표)</h3>
<ul>
    <li><strong>빌드 자동화 및 표준화:</strong> 개발자가 코드를 <code>Push</code>하면, 젠킨스가 <mark>표준화된 환경에서 펌웨어를 자동으로 빌드</mark>하도록 조율합니다.</li>
    <li><strong>산출물 중앙 관리:</strong> 모든 빌드 산출물(펌웨어 파일)은 젠킨스의 제어에 따라 NAS 혹은 **Nexus**와 같은 <mark>중앙 저장소에 자동으로 업로드되고 버전이 부여</mark>됩니다.</li>
    <li><strong>신뢰성 및 추적성 확보:</strong> 모든 펌웨어 파일은 어떤 소스 코드(Git Commit)로, <mark>언제, 어떻게 빌드되었는지 완전한 이력 추적</mark>이 가능해집니다.</li>
    <li><strong>신속한 테스트 피드백:</strong> 개발자는 젠킨스 알림을 통해 빌드 성공/실패 여부를 즉시 확인하고, NAS 혹은 중앙 저장소(Nexus)에서 <mark>검증된 파일을 다운로드하여 즉시 하드웨어(H/W) 테스트를 수행</mark>할 수 있습니다.</li>
</ul>

<hr>

<h2>3. 젠킨스의 역할과 연동 도구</h2>

<p>젠킨스는 파이프라인을 <strong>조율(Orchestration)</strong>하고, 실제 작업은 <strong>연동된 전문 도구(Tools)</strong>가 <strong>실행(Execution)</strong>합니다.</p>

<table>
    <thead>
    <tr>
        <th>자동화 영역</th>
        <th>젠킨스의 역할 (조율) - 예시</th>
        <th>연동 도구의 역할 (실행) - 예시</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><strong>펌웨어 빌드</strong></td>
        <td><code>ps1</code>, <code>bat</code> 등 빌드 스크립트 호출</td>
        <td><code>IAR</code>, <code>Keil</code>, <code>GCC</code> 등 <strong>펌웨어 컴파일러</strong>가 컴파일 실행</td>
    </tr>
    <tr>
        <td><strong>정적 분석</strong></td>
        <td>Coverity 플러그인 또는 분석 스크립트 호출</td>
        <td><strong>Coverity 툴</strong>이 소스 코드를 스캔하고 분석 실행</td>
    </tr>
    <tr>
        <td><strong>동적 분석</strong></td>
        <td>Codescroll CT의 CLI (명령어) 호출</td>
        <td>Codescroll Controller Tester<strong>가 펌웨어를 실행/테스트하고 결과 분석</strong> 실행</td>
    </tr>
    <tr>
        <td><strong>산출물 관리</strong></td>
        <td>Nexus Uploader 플러그인 혹은 NAS 명령어 호출</td>
        <td>Nexus 혹은 NAS 서버가 <strong>파일을 수신하여 저장/버전 관리 실행</strong></td>
    </tr>
    <tr>
        <td><strong>알림</strong></td>
        <td>Works 또는 Email 플러그인을 통해 메시지 전송 요청</td>
        <td><code>Works API</code> 또는 <code>SMTP 서버</code>가 메시지를 발송</td>
    </tr>
    </tbody>
</table>

<hr>

<h2>4. 작업(Job) 예시 및 역할 구분</h2>

<table>
    <thead>
    <tr>
        <th><strong>작업 예시</strong></th>
        <th>4-1. 로컬 빌드 (개발자 PC)</th>
        <th>4-2. 공식(릴리스) 빌드 (젠킨스)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><strong>목적</strong></td>
        <td>개발자 1차 자가 검증</td>
        <td>릴리스용 <strong>신뢰할 수 있는(Trusted) 펌웨어 파일</strong> 생성</td>
    </tr>
    <tr>
        <td><strong>시점</strong></td>
        <td>개발자가 PC에서 <strong>수동 실행</strong> (빌드 스크립트)</td>
        <td>release 브랜치로 <strong>병합 또는 태그 생성 시</strong></td>
    </tr>
    </tbody>
</table>
<hr>

<h2>5. 논의 사항</h2>

<p>젠킨스 도입의 성공은 기술이 아닌 <mark>합의된 규칙(정책)을 준수하는 것</mark>에 달려있습니다. 아래 주제들에 대해 논의와 협의가 필요합니다.</p>

<h3>5-1. 깃 브랜치 전략 (현행 및 개선안)</h3>
<p>CI/CD 파이프라인은 Git 전략과 1:1로 연결되어야 합니다. <br> <mark>자동 빌드 구분과 품질 관리를 위해 현행 전략의 표준화가 필요</mark>합니다.</p>
<h4>5-1-1. 현행 방식 (As-Is)</h4>
<ul>
    <li>하나의 레포에서 브랜치를 모델(<code>400</code>, <code>500</code>) 구분용으로 사용 중입니다. 이는 <mark>Git의 본래 목적인 '버전 관리'가 아닌 '폴더 구분' 용도</mark>로 오용하는 것입니다.</li>
    <li><code>400</code> 모델 빌드 시 <mark>불필요한 <code>500</code> 모델 코드까지 모두 가져와(clone) CPU, RAM, Disk 자원을 심각하게 낭비</mark>합니다.</li>
    <li>이는 빌드 시간 증가, 서버 비용 상승, 브랜치 입력 실수 등 <mark>휴먼 에러를 유발</mark>합니다.</li>
</ul>
<h4>5-1-2. 제안 개선안(TO-BE)</h4>
<ul>
    <li><strong>전략 변경:</strong> 모델별 브랜치를 폐기하고, **모델별 레포지토리로 분리**합니다.</li>
    <li><strong>표준 적용:</strong> 모든 레포에 <strong><code>prod</code>(공식), <code>develop</code>(통합), <code>feature</code>(기능)</strong> 브랜치 전략을 적용합니다.</li>
    <li><strong>핵심 브랜치 보호:</strong> <code>prod</code>, <code>develop</code> 브랜치는 <mark>직접 Push를 절대 금지</mark> (Protected Branch 설정)하고, 항상 배포 가능한 상태를 유지합니다.</li>
    <li><strong><code>feature</code> 브랜치 활용:</strong> 모든 개발은 <code>feature</code>에서 진행하며, Push 시 젠킨스가 자동 검증(비공식 빌드)합니다.</li>
</ul>
<h4>5-1-3. 개선안 도입 시 기대 효과</h4>
<ul>
    <li><strong>자원 효율화 (비용 절감):</strong> 레포 분리로 <mark>빌드에 필요한 코드만 clone</mark>합니다. 이는 **CPU, RAM, Disk 낭비를 제거**하고 <mark>빌드 준비 시간을 획기적으로 단축</mark>시킵니다.</li>
    <li><strong>CI/CD 연동 강화:</strong> 젠킨스가 <mark><code>feature</code>, <code>develop</code>, <code>prod</code> 브랜치 목적을 명확히 인지</mark>하고, 각기 다른 자동화(검증, 통합, 릴리스)를 실행합니다.</li>
    <li><strong>품질 및 안정성 확보:</strong> 핵심 브랜치 보호를 통해 <mark>검증되지 않은 코드의 통합/릴리스를 원천 차단</mark>합니다.</li>
    <li><strong>프로세스 정상화:</strong> Git을 본래 목적인 '버전 관리'로 사용하게 됩니다. <mark>브랜치 입력 실수 등 휴먼 에러가 감소</mark>하고, <code>prod</code> 브랜치에 '깨끗한 릴리스 이력'만 남게 됩니다.</li>
</ul>
<h4>5-1-4. 예상되는 불편한 점 (도입 장벽)</h4>
<p>새로운 전략 도입 시 다음과 같은 초기 불편함이나 학습 비용이 발생할 수 있습니다.</p>
<ul>
    <li><strong>초기 마이그레이션 비용:</strong> 단일 레포를 모델별로 분리하는 <mark>초기 마이그레이션 작업에 리소스가 투입</mark>됩니다.</li>
    <li><strong>공통 코드 관리 복잡성:</strong> 모델 간 공통 코드를 <mark>별도 <code>common_code</code> 레포(예: <strong><code>Git Submodule</code></strong>)</mark>로 관리해야 할 수 있습니다. 이는 <mark>추가 작업 단계와 새로운 학습</mark>을 요구합니다.</li>
    <li><strong>새로운 워크플로우 학습:</strong> <code>feature</code> 브랜치, <strong><code>Pull Request (PR)</code></strong>, 코드 리뷰 등 <mark>새로운 프로세스에 대한 학습 및 적응 기간</mark>이 필요합니다.</li>
    <li><strong>관리 오버헤드:</strong> 개발자가 <mark>여러 레포를 넘나들며(Context Switching)</mark> 작업해야 하는 부담이 생깁니다.</li>
</ul>

<hr>

<h3>5-2. 빌드 실행 시점 (트리거) 논의</h3>

<p>젠킨스 빌드를 '언제' 실행할지 명확한 규칙이 필요합니다. 이는 <code>5-1</code>의 브랜치 전략과 직접 연동됩니다.</p>

<div class="option-card">
    <strong>방법 1: 브랜치별 트리거 -> 브랜치 전략 변경 시</strong>
    <ul>
        <li><strong><code>feature</code> / <code>develop</code> 브랜치 (비공식/통합 빌드):</strong>
            <ul>
                <li>개발자가 코드를 <code>Push</code>할 때마다 <mark>자동으로 빌드를 실행</mark>후 메일 전송.</li>
            </ul>
        </li>
        <li><strong><code>prod</code> 브랜치 (공식 릴리스 빌드):</strong>
            <ul>
                <li><code>v1.2.0</code>과 같은 <mark>Git 태그(Tag)를 생성하는 시점</mark>에만 공식 빌드가 실행 후 NAS or Nexus</li>
            </ul>
        </li>
    </ul>
</div>

<div class="option-card">
    <strong>방법 2: 기타 트리거</strong>
    <ul>
        <li><strong>주기적인 빌드 (Nightly Build):</strong>
            <ul>
                <li>매일 자정, <code>develop</code> 브랜치의 최신 코드를 가져와 빌드 및 분석을 수행하는 방안. (코드 품질 리포트 생성 목적)</li>
            </ul>
        </li>
        <li><strong>수동 빌드 (Manual Build):</strong>
            <ul>
                <li>긴급 핫픽스, 특정 버전 재빌드 등을 위해 젠킨스 화면에서 <mark>버튼을 클릭하여 수동으로 실행</mark>하는 기능도 함께 제공. (수동 빌드 시 메일 전송 불가)</li>
            </ul>
        </li>
    </ul>
</div>

<h3>5-3. 산출물 중앙 저장소 논의</h3>

<p>AS-IS의 "수동 공유" 및 "버전 관리 혼선" 문제를 해결하려면, 빌드 산출물을 관리할 <mark>단일 중앙 저장소(Single Source of Truth)</mark>가 반드시 필요합니다. 가능한 대안은 다음과 같습니다.</p>

<div class="option-card">
    <strong>방법 1: 기존 NAS 활용</strong>
    <ul>
        <li><strong>장점:</strong> 이미 보유한 자원을 활용합니다.</li>
        <li><strong>필요조건 :</strong> 젠킨스 빌드 에이전트(서버)가 NAS의 특정 폴더에 <mark>파일을 자동으로 쓰고/읽을 수 있도록 전산팀의 접근 권한 허용</mark>이 필요합니다. (전산팀의 문의한 결과 권한을 주는 부분은 업체 확인이 필요하다는 내용 전달받았습니다.)</li>
        <li><strong>단점:</strong> 펌웨어 버전 관리(<code>v1.2.0</code>)나 오래된 파일 자동 삭제(Retention) 로직을 젠킨스 파이프라인 스크립트로 **직접 구현해야** 합니다.</li>
    </ul>
</div>

<div class="option-card">
    <strong>방법 2: Nexus (OSS) 신규 구축</strong>
    <ul>
        <li><strong>배경:</strong> 옵션 1의 전산팀 권한 작업이 어렵거나, 더 체계적인 관리를 원할 경우의 대안입니다.</li>
        <li><strong>장점:</strong>
            <ul>
                <li><mark>자동 버전 관리</mark> (<code>Release</code>/<code>Snapshot</code> 구분) 기능을 기본 제공합니다.</li>
                <li>오래된 파일을 <mark>자동으로 삭제하는 정책(Cleanup Policy)</mark>을 지원합니다. (<code>5-4</code> 참고)</li>
                <li>젠킨스와의 연동이 간단합니다.</li>
            </ul>
        </li>
        <li><strong>단점:</strong> Nexus를 설치하고 운영할 서버(Jenkins 서버 혹은 페스카로 kms 서버 같이 활용)가 필요합니다.</li>
    </ul>
</div>

<h3>5-4. 산출물 관리 (보관 및 삭제) 논의</h3>

<p><code>5-3</code>에서 중앙 저장소가 결정된다는 전제 하에, 산출물을 "어떻게 관리(버전)"하고 "어떻게 삭제(주기)"할지 정책이 필요합니다.</p>

<div class="option-card">
    <p><strong>논의 1: 산출물 보관 및 버전 관리 방안</strong></p>
    <ul>
        <li>1. 파일명</li>
        <li>2. 저장 정보</li>
        <li>3. 폴더 구조</li>
        <li>4. 저장할 파일수</li>
    </ul>
</div>

<div class="option-card">
    <strong>논의 2: 산출물 삭제 정책 (저장 주기)</strong>
    <p>1. 공식 릴리즈 산출물 삭제 주기(상황), 파일수 <br> 예시) 삭제 기준: 최근 7일 또는 최신 5개만 보관</p>
</div>

</body>
</html>